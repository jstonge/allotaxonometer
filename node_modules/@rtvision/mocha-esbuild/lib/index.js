"use strict";
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const tmp_promise_1 = require("tmp-promise");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const Helpers_1 = require("./Helpers");
const Esbuild_1 = (0, tslib_1.__importDefault)(require("./Esbuild"));
const mochaFlags = {
    bail: command_1.flags.boolean({
        char: 'b',
        description: 'Bail on the first test failure.',
        default: false
    }),
    color: command_1.flags.boolean({
        char: 'c',
        description: 'Color TTY output from reporter.',
        default: false
    }),
    fgrep: command_1.flags.string({
        description: 'Test filter given string'
    }),
    fullTrace: command_1.flags.string({
        description: 'Full stacktrace upon failure?'
    }),
    grep: command_1.flags.string({
        char: 'g',
        description: 'Test filter given regular expression.'
    }),
    invert: command_1.flags.boolean({
        description: 'Invert test filter matches?',
        default: false
    }),
    timeout: command_1.flags.string({
        char: 't',
        description: 'Timeout threshold value for mocha.'
    }),
    require: command_1.flags.string({
        char: 'r',
        description: 'Pathname of file that will be imported before tests run'
    }),
    reporter: command_1.flags.string({
        description: 'Reporter name to use'
    }),
    retries: command_1.flags.integer({
        description: 'Number of times to retry failed tests'
    }),
    parallel: command_1.flags.boolean({
        char: 'p',
        description: 'Run test in parallel.',
        default: false
    }),
    jobs: command_1.flags.integer({
        description: 'Max number of worker processes for parallel runs',
        dependsOn: ['parallel']
    })
};
class MochaEsbuild extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(MochaEsbuild);
        let mochaOptions = {};
        for (const mochaFlag in mochaFlags) {
            const flagValue = flags[mochaFlag];
            if (flagValue) {
                mochaOptions[mochaFlag] = flagValue;
            }
        }
        if (Object.keys(mochaOptions).length === 0)
            mochaOptions = null;
        const outputFile = `${await (0, tmp_promise_1.tmpName)({ tmpdir: process.cwd(), prefix: '.temp-mocha-esbuild' })}.mjs`;
        process.on('SIGINT', async () => {
            await (0, Helpers_1.cleanUp)(outputFile);
            process.exit();
        });
        process.on('uncaughtException', async () => {
            await (0, Helpers_1.cleanUp)(outputFile);
            process.exit();
        });
        const onRebuild = error => {
            if (error) {
                console.error('watch build failed:', error);
            }
            else {
                console.clear();
                this.log(chalk_1.default.green('Rebuild successful, starting tests'));
                (0, Helpers_1.initWorker)(outputFile, { mochaOptions, mochaConfigPath: flags.mochaConfigPath });
            }
        };
        this.log(chalk_1.default.cyan('Config processed, starting esbuild'));
        await (0, Esbuild_1.default)(args.file, outputFile, {
            watch: flags.watch,
            sourcemap: flags.sourcemap,
            importSourceMapSupport: !flags.noImportSourceMapSupport,
            esbuildConfigPath: flags.esbuildConfig,
            onRebuild
        });
        this.log(chalk_1.default.green('Build was successful, running tests'));
        if (flags.watch === false) {
            const failures = await (0, Helpers_1.runMocha)(outputFile, { mochaOptions, mochaConfigPath: flags.mochaConfigPath });
            await (0, Helpers_1.cleanUp)(outputFile);
            if (failures > 0)
                process.exit(1);
        }
        else {
            (0, Helpers_1.initWorker)(outputFile, { mochaOptions, mochaConfigPath: flags.mochaConfigPath });
        }
    }
}
MochaEsbuild.description = 'Run tests with mocha compiled by esbuild';
MochaEsbuild.flags = Object.assign({ version: command_1.flags.version({ char: 'v' }), help: command_1.flags.help({ char: 'h' }), esbuildConfig: command_1.flags.string({
        default: '.esbuildrc.js',
        description: 'Esbuild config file path. The follow options will always be overwritten: bundle, stdin/entryPoints, and outfile'
    }), mochaConfigPath: command_1.flags.string({
        description: 'Filepath to read mocha configs from, can be js or json file'
    }), watch: command_1.flags.boolean({
        char: 'w',
        default: false,
        description: 'Enable watch mode for esbuild. Will overwrite watch if custom config provided'
    }), sourcemap: command_1.flags.boolean({
        char: 's',
        default: false,
        description: 'Generates inline sourcemaps for easier debugging. Will overwrite sourcemaps if custom config provided'
    }), noImportSourceMapSupport: command_1.flags.boolean({
        default: false,
        description: 'Disable the importing source-map-support package when sourcemap enabled'
    }) }, mochaFlags);
MochaEsbuild.args = [{
        name: 'file',
        default: 'test/unit/**/*.spec.js',
        description: 'File path to the entry point to build from. Can be 1 specific file or take a globstar such as \'test/unit/**/*.spec.js\''
    }];
module.exports = MochaEsbuild;
