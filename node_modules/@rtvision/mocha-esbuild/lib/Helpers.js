"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRelativePath = exports.cleanUp = exports.runMocha = exports.initWorker = exports.importESM = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const fs_1 = require("fs");
const worker_threads_1 = require("worker_threads");
const mocha_1 = (0, tslib_1.__importDefault)(require("mocha"));
/**
 * From: https://github.com/webpack/webpack-cli/blob/0fa244b0/packages/webpack-cli/lib/utils/dynamic-import-loader.js
 *
 * We can't directly call "import" because TypeScript compiles it
 * https://github.com/microsoft/TypeScript/issues/43329
 */
function importESM(specifier) {
    // eslint-disable-next-line no-new-func
    const indirectImport = new Function('id', 'return import(id);');
    return indirectImport(specifier);
}
exports.importESM = importESM;
let previousWorker = null;
function initWorker(bundledFile, { mochaOptions, mochaConfigPath }) {
    const worker = new worker_threads_1.Worker((0, path_1.resolve)(__dirname, './worker/MochaEsbuildWorker.js'), { workerData: { filename: bundledFile, mochaOptions, mochaConfigPath } });
    if (previousWorker !== null)
        previousWorker.terminate();
    previousWorker = worker;
    worker.once('message', () => {
        worker.terminate();
        runMocha(bundledFile, { isWorker: true });
    });
    worker.on('error', async (error) => {
        console.error(error);
    });
}
exports.initWorker = initWorker;
async function getMochaConfig(filePath = null) {
    let usedFilePath = resolveRelativePath(filePath !== null && filePath !== void 0 ? filePath : '.mocharc.json');
    // esm modules are unable to import .json file types as of node16
    if ((0, path_1.extname)(usedFilePath) === '.json' && (0, fs_1.existsSync)(usedFilePath)) {
        return JSON.parse(await fs_1.promises.readFile(usedFilePath, 'utf-8'));
    }
    else if (filePath === null) {
        usedFilePath = resolveRelativePath('.mocharc.js');
    }
    if (!(0, fs_1.existsSync)(usedFilePath))
        return null;
    return (await Promise.resolve().then(() => (0, tslib_1.__importStar)(require(usedFilePath)))).default;
}
async function runMocha(filename, { mochaOptions = null, isWorker = false, mochaConfigPath = null } = {}) {
    var _a;
    const fileMochaOptions = (_a = await getMochaConfig(mochaConfigPath)) !== null && _a !== void 0 ? _a : {};
    mochaOptions = Object.assign(Object.assign({}, fileMochaOptions), mochaOptions);
    if (isWorker)
        mochaOptions.isWorker = true;
    if (typeof mochaOptions.require === 'string') {
        let importFileName = mochaOptions.require;
        if (!mochaOptions.require.startsWith('.'))
            importFileName = `${process.cwd()}/${importFileName}`;
        if ((0, fs_1.existsSync)(mochaOptions.require)) {
            await importESM(importFileName);
        }
        delete mochaOptions.require;
    }
    const mocha = new mocha_1.default(mochaOptions);
    mocha.files = [filename];
    await mocha.loadFilesAsync();
    return new Promise(resolve => mocha.run(resolve));
}
exports.runMocha = runMocha;
async function cleanUp(file) {
    if ((0, fs_1.existsSync)(file))
        await fs_1.promises.unlink(file);
    const cssFile = file.replace('.mjs', '.css');
    if ((0, fs_1.existsSync)(cssFile))
        await fs_1.promises.unlink(cssFile);
}
exports.cleanUp = cleanUp;
function resolveRelativePath(filePath) {
    if (!(0, path_1.isAbsolute)(filePath))
        return (0, path_1.resolve)(process.cwd(), filePath);
    return filePath;
}
exports.resolveRelativePath = resolveRelativePath;
